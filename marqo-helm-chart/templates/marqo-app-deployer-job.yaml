apiVersion: batch/v1
kind: Job
metadata:
  name: marqo-app-deployer
  namespace: {{ include "marqo.namespace" . }}
  annotations:
    "helm.sh/hook": post-install
    "helm.sh/hook-weight": "15"  # Run after vespa-app-deployment
    "helm.sh/hook-delete-policy": hook-succeeded,hook-failed
    "helm.sh/hook-timeout": "15m"
spec:
  backoffLimit: 5
  template:
    spec:
      restartPolicy: OnFailure
      initContainers:
      - name: wait-for-vespa-init
        image: alpine:latest
        command: ["/bin/sh", "-c"]
        args:
        - |
          # Install required tools
          echo "Installing required packages..."
          apk add --no-cache curl bind-tools bash
          
          echo "Waiting for all infrastructure to be ready..."
          echo "Starting initialization checks at $(date)"
          
          # Define variables for shorter references
          NAMESPACE="{{ include "marqo.namespace" . }}"
          echo "Using namespace: $NAMESPACE"
          
          # Correct DNS format for StatefulSet pods
          CONFIG0="vespa-configserver-0.vespa-internal.$NAMESPACE.svc.cluster.local"
          CONFIG1="vespa-configserver-1.vespa-internal.$NAMESPACE.svc.cluster.local"
          CONFIG2="vespa-configserver-2.vespa-internal.$NAMESPACE.svc.cluster.local"
          
          echo "Configured config server endpoints:"
          echo "- $CONFIG0"
          echo "- $CONFIG1"
          echo "- $CONFIG2"
          
          # Initial sleep to allow services to start
          echo "Sleeping for 30 seconds to allow Vespa initialization ($(date))"
          sleep 30
          
          # Direct check on health endpoint with detailed output
          echo "Performing direct health endpoint checks on config servers..."
          for i in $(seq 1 20); do
            echo "Health check attempt $i/20 at $(date)"
            CONFIG0_OK=false
            CONFIG1_OK=false
            CONFIG2_OK=false
            
            # Check each server with detailed output
            echo "Testing configserver-0 state/v1/health endpoint..."
            CONFIG0_RESULT=$(curl -s -m 5 "http://$CONFIG0:19071/state/v1/health" 2>&1)
            echo "CONFIG0 response: ${CONFIG0_RESULT:0:100}"
            if echo "$CONFIG0_RESULT" | grep -q "up"; then
              echo "✓ Config server 0 reports UP status"
              CONFIG0_OK=true
            else
              echo "Config server 0 not reporting UP status yet"
            fi
            
            echo "Testing configserver-1 state/v1/health endpoint..."
            CONFIG1_RESULT=$(curl -s -m 5 "http://$CONFIG1:19071/state/v1/health" 2>&1)
            echo "CONFIG1 response: ${CONFIG1_RESULT:0:100}"
            if echo "$CONFIG1_RESULT" | grep -q "up"; then
              echo "✓ Config server 1 reports UP status"
              CONFIG1_OK=true
            else
              echo "Config server 1 not reporting UP status yet"
            fi
            
            echo "Testing configserver-2 state/v1/health endpoint..."
            CONFIG2_RESULT=$(curl -s -m 5 "http://$CONFIG2:19071/state/v1/health" 2>&1)
            echo "CONFIG2 response: ${CONFIG2_RESULT:0:100}"
            if echo "$CONFIG2_RESULT" | grep -q "up"; then
              echo "✓ Config server 2 reports UP status"
              CONFIG2_OK=true
            else
              echo "Config server 2 not reporting UP status yet"
            fi
            
            # If any two config servers are up, we can continue
            if { [ "$CONFIG0_OK" = "true" ] && [ "$CONFIG1_OK" = "true" ]; } || \
               { [ "$CONFIG0_OK" = "true" ] && [ "$CONFIG2_OK" = "true" ]; } || \
               { [ "$CONFIG1_OK" = "true" ] && [ "$CONFIG2_OK" = "true" ]; }; then
              echo "✓ Sufficient config servers are up and running!"
              break
            fi
            
            # Check if any server is up to provide better diagnostics
            if [ "$CONFIG0_OK" = "true" ] || [ "$CONFIG1_OK" = "true" ] || [ "$CONFIG2_OK" = "true" ]; then
              echo "At least one config server is up, waiting for more..."
            else
              echo "No config servers are reporting UP status yet. Will continue checking..."
            fi
            
            echo "Waiting 15 seconds before next health check attempt..."
            sleep 15
            
            # Last attempt, continue anyway to let the job proceed
            if [ $i -eq 20 ]; then
              echo "WARNING: Not all config servers are reporting UP status, but continuing anyway"
            fi
          done
          
          echo "Performing minimal API check..."
          # Just try one quick check without extensive retries
          if curl -s -m 5 -o /dev/null "http://$CONFIG0:19071/ApplicationStatus" 2>/dev/null; then
            echo "✓ Config server 0 API appears to be responsive!"
          elif curl -s -m 5 -o /dev/null "http://$CONFIG1:19071/ApplicationStatus" 2>/dev/null; then
            echo "✓ Config server 1 API appears to be responsive!"
          elif curl -s -m 5 -o /dev/null "http://$CONFIG2:19071/ApplicationStatus" 2>/dev/null; then
            echo "✓ Config server 2 API appears to be responsive!"
          else
            echo "INFO: Config server APIs are not responding yet, but this is less important than DNS/TCP connectivity"
          fi
          
          # After checking config servers, check content servers at network level
          echo "Checking content servers network availability..."
          
          for i in $(seq 1 15); do
            echo "Content server network check attempt $i/15..."
            SUCCESS=false
            
            # Try multiple content servers
            for cs_id in 0 1 2; do
              CS_HOST="vespa-content-server-$cs_id.vespa-content.$NAMESPACE.svc.cluster.local"
              echo "Testing content server $cs_id DNS resolution..."
              
              # Only check if DNS resolves, no port checking
              if nslookup $CS_HOST 2>/dev/null; then
                echo "✓ DNS resolution successful for content server $cs_id"
                SUCCESS=true
                break
              else
                echo "DNS resolution failed for content server $cs_id"
              fi
            done
            
            if [ "$SUCCESS" = "true" ]; then
              echo "✓ At least one content server DNS resolves - sufficient for proceeding!"
              break
            fi
            
            echo "Waiting for content servers... (attempt $i/15)"
            sleep 15
            
            # Last attempt, continue anyway
            if [ $i -eq 15 ]; then
              echo "WARNING: No content servers appear to be DNS-resolvable, but continuing anyway"
            fi
          done
          
          echo "Initialization checks completed at $(date) - proceeding with app deployment!"
      - name: build-app-package
        image: alpine:latest
        command: ["/bin/sh", "-c"]
        args:
        - |
          echo "Starting app.zip build process..."
          
          # Improved error handling
          set -e
          trap 'echo "Error occurred at line $LINENO. Command: $BASH_COMMAND"' ERR
          
          # Install zip and other required tools
          echo "Installing required packages..."
          apk add --no-cache zip curl jq
          
          # Debug info
          echo "Checking environment and filesystem..."
          echo "Working directory: $(pwd)"
          
          # Verify directories exist
          echo "Checking and creating directories..."
          mkdir -p /app-templates /tmp /app-output
          
          # Check if we can write to /tmp
          echo "Testing write access to /tmp..."
          echo "test" > /tmp/test.txt && echo "✓ Can write to /tmp" || echo "❌ Cannot write to /tmp"
          ls -la /tmp
          
          # Debug the script source
          echo "Debugging script source:"
          ls -la /scripts/ || echo "Cannot list /scripts"
          
          # Execute script directly without copying
          echo "Executing build script directly..."
          if [ -f "/scripts/build-app-zip.sh" ]; then
            echo "Build script found. Content:"
            cat /scripts/build-app-zip.sh
            
            echo "Executing script content directly..."
            # Source the script content directly
            /bin/sh -c "$(cat /scripts/build-app-zip.sh)"
          else
            echo "ERROR: Build script not found at /scripts/build-app-zip.sh"
            exit 1
          fi
          
          # Verify the output was created
          echo "Checking for generated app.zip..."
          if [ -f "/app-output/app.zip" ]; then
            echo "✓ app.zip was successfully created"
            ls -la /app-output/
          else
            echo "ERROR: app.zip was not created in /app-output/"
            exit 1
          fi
        volumeMounts:
        - name: app-templates
          mountPath: /app-templates
        - name: scripts
          mountPath: /scripts
        - name: app-directory
          mountPath: /app-output
      - name: setup-app-directory
        image: busybox
        command: ["/bin/sh", "-c"]
        args:
        - |
          echo "Setting up application directory structure..."
          mkdir -p /app-setup/schemas
          chmod -R 777 /app-setup
          echo "Application directory structure created and permissions set."
        volumeMounts:
        - name: app-directory
          mountPath: /app-setup
      containers:
      - name: vespa-deployer
        image: {{ .Values.vespaContentServer.image }}
        command: ["/bin/sh", "-c"]
        args:
        - |
          echo "Checking application directory"
          ls -la /app
          
          echo "Application directory contents:"
          find /app -type f | sort
          
          echo "Deploying Vespa application..."
          cd /app
          
          # Set explicit config server
          export VESPA_CONFIGSERVERS="vespa-configserver-0.vespa-internal.{{ include "marqo.namespace" . }}.svc.cluster.local:19071,vespa-configserver-1.vespa-internal.{{ include "marqo.namespace" . }}.svc.cluster.local:19071,vespa-configserver-2.vespa-internal.{{ include "marqo.namespace" . }}.svc.cluster.local:19071"
          
          # Add retry logic for deployment
          for attempt in $(seq 1 5); do
            echo "Deployment attempt $attempt of 5..."
            echo "Running deploy with VESPA_CONFIGSERVERS=$VESPA_CONFIGSERVERS"
            echo "Current directory contents:"
            ls -la
            
            if [ -f "app.zip" ]; then
              echo "Found app.zip, using direct deployment method"
              if curl -s --header Content-Type:application/zip --data-binary @app.zip "http://vespa-configserver-0.vespa-internal.{{ include "marqo.namespace" . }}.svc.cluster.local:19071/application/v2/tenant/default/prepareandactivate"; then
                echo "Application deployment successful!"
                break
              fi
            else
              echo "Using vespa-deploy method"
              if /opt/vespa/bin/vespa-deploy prepare /app && /opt/vespa/bin/vespa-deploy activate; then
                echo "Application deployment successful!"
                break
              fi
            fi
            
            echo "Deployment attempt $attempt failed. Waiting before retry..."
            sleep 30
            
            # If this is the last attempt and it failed, we'll still continue
            if [ $attempt -eq 5 ]; then
              echo "Warning: All deployment attempts failed, but continuing..."
            fi
          done
          
          # Verify deployment
          echo "Checking application deployment status:"
          /opt/vespa/bin/vespa-deploy status || true
        volumeMounts:
        - name: app-directory
          mountPath: /app
      volumes:
      - name: app-templates
        configMap:
          name: marqo-app-templates
      - name: scripts
        configMap:
          name: marqo-app-config
          items:
          - key: build-app-zip.sh
            path: build-app-zip.sh
      - name: app-directory
        emptyDir: {}